.CODE

PUSH simple_heap_init 
CALL
PUSH lmain@@Init
CALL
HALT

simple_heap_init: 
RET 0 ; Retorna inmediatamente

simple_malloc:
LOADFP	; Inicialización unidad
LOADSP
STOREFP ; Finaliza inicialización del RA
LOADHL	; hl
DUP	; hl
PUSH 1	; 1
ADD	; hl+1
STORE 4 ; Guarda el resultado (un puntero a la primer celda de la región de memoria)
LOAD 3	; Carga la cantidad de celdas a alojar (parámetro que debe ser positivo)
ADD
STOREHL ; Mueve el heap limit (hl). Expande el heap
STOREFP
RET 1	; Retorna eliminando el parámetro




.DATA
VT_A: DW lmet3A@@A,lmet1A@@A

.CODE
lmet3A@@A:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lmet4A@@A:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 0 ; Retorna de la unidad liberando n lugares en la pila

lmet1A@@A:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lmet2A@@A:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 0 ; Retorna de la unidad liberando n lugares en la pila

lA@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_Init: NOP

.CODE
lmain@@Init:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
RMEM 1 ; Reservo memoria para el puntero al comienzo del String que se almacenara en .HEAP
PUSH 5 ; Parametro del malloc. Reservo n + 1 lugares en el heap, donde n es la cantidad de letras del String y +1 para el caracter terminador (valor 0)
PUSH simple_malloc
CALL
DUP ; Duplico la referencia del comienzo del String ya que STOREREF la consumira para almacenar el proximo caracter
PUSH 'H' ; apilo la letra i-esima del string en HEAP
STOREREF 0 ; Guardo la letra apilada
DUP ; Duplico la referencia del comienzo del String ya que STOREREF la consumira para almacenar el proximo caracter
PUSH 'O' ; apilo la letra i-esima del string en HEAP
STOREREF 1 ; Guardo la letra apilada
DUP ; Duplico la referencia del comienzo del String ya que STOREREF la consumira para almacenar el proximo caracter
PUSH 'L' ; apilo la letra i-esima del string en HEAP
STOREREF 2 ; Guardo la letra apilada
DUP ; Duplico la referencia del comienzo del String ya que STOREREF la consumira para almacenar el proximo caracter
PUSH 'A' ; apilo la letra i-esima del string en HEAP
STOREREF 3 ; Guardo la letra apilada
DUP ; Duplico la referencia del comienzo del String ya que STOREREF la consumira para almacenar el proximo caracter
PUSH 0 ; Apilo el caracter terminador
STOREREF 4 ; Guardo el caracter terminador en el heap. Indica que es el fin del String
PUSH lprintS@String@System ; Pongo la etiqueta del metodo
CALL
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 0 ; Retorna de la unidad liberando n lugares en la pila

lInit@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_B: DW lmet3A@@A,lmet1A@@B,lmet1B@@B

.CODE
lmet1B@@B:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lmet1A@@B:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lmet2A@@B:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 0 ; Retorna de la unidad liberando n lugares en la pila

lB@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_C: DW lmet3A@@A,lmet1A@@B,lmet1B@@B

.CODE
lC@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_Object: NOP

.CODE
ldebugPrint@int@Object:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lObject@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_System: NOP

.CODE
lread@@System:
LOADFP
LOADSP
STOREFP
READ    ; Lectura de un digito entero
PUSH 48 ; Apilamos un 48 para restarselo al ASCII del digito y así obtener el número
SUB
STORE 3 ; Ponemos el tope de la pila en la locación reservada. En 1 esta ED y en 2 PR, no hay this ni parametros
STOREFP
RET 0 ; +0 ya que no tiene this y no tiene parametros formales

lprintCln@char@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
CPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintC@char@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
CPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintBln@boolean@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
BPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintI@int@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintIln@int@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintSln@String@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro que es una referencia al String en la heap
SPRINT
PRNLN
STOREFP
RET 1

lprintB@boolean@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
BPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintS@String@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro que es una referencia al String en la heap
SPRINT
STOREFP
RET 1

lprintln@@System:
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 0 ; +0 ya que no tiene this y no tiene parametros formales

lSystem@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



