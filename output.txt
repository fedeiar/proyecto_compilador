.CODE

PUSH simple_heap_init 
CALL
PUSH lmain()Init
CALL
HALT

simple_heap_init: 
RET 0 ; Retorna inmediatamente

simple_malloc:
LOADFP	; Inicialización unidad
LOADSP
STOREFP ; Finaliza inicialización del RA
LOADHL	; hl
DUP	; hl
PUSH 1	; 1
ADD	; hl+1
STORE 4 ; Guarda el resultado (un puntero a la primer celda de la región de memoria)
LOAD 3	; Carga la cantidad de celdas a alojar (parámetro que debe ser positivo)
ADD
STOREHL ; Mueve el heap limit (hl). Expande el heap
STOREFP
RET 1	; Retorna eliminando el parámetro


.DATA
VT A: DW lmet1()A,lmet1(char)A
.CODE
lmet1()A:
lmet1(char)A:
lA():

.DATA
VT B: DW lmet1()A,lmet1(char)B,lmet1(int)B,lmet1(String)B
.CODE
lmet1(int)B:
lmet1(char)B:
lmet1(String)B:
lB():

.DATA
VT Init: NOP
.CODE
lmain()Init:
lInit():

.DATA
VT C: DW lmet1()A,lmet1(char)B,lmet1(int)B,lmet1(String)B,lmet1(char,char)C,lmet1(int,char)C
.CODE
lmet1(char,char)C:
lmet1(int,char)C:
lC():

.DATA
VT D: DW lmet1()A,lmet1(char)B,lmet1(int)B,lmet1(String)D,lmet1(char,char)C,lmet1(int,char)C
.CODE
lmet1(String)D:
lD():

.DATA
VT E: DW lmet1()A,lmet1(char)B,lmet1(int)B,lmet1(String)D,lmet1(char,char)C,lmet1(int,char)C
.CODE
lE():

.DATA
VT Object: NOP
.CODE
ldebugPrint(int)Object:
lObject():

.DATA
VT System: NOP
.CODE
lread()System:
lprintCln(char)System:
lprintC(char)System:
lprintBln(boolean)System:
lprintI(int)System:
lprintIln(int)System:
lprintSln(String)System:
lprintB(boolean)System:
lprintS(String)System:
lprintln()System:
lSystem():

