.CODE

PUSH simple_heap_init 
CALL
PUSH lmain@@A
CALL
HALT

simple_heap_init: 
RET 0 ; Retorna inmediatamente

simple_malloc:
LOADFP	; Inicialización unidad
LOADSP
STOREFP ; Finaliza inicialización del RA
LOADHL	; hl
DUP	; hl
PUSH 1	; 1
ADD	; hl+1
STORE 4 ; Guarda el resultado (un puntero a la primer celda de la región de memoria)
LOAD 3	; Carga la cantidad de celdas a alojar (parámetro que debe ser positivo)
ADD
STOREHL ; Mueve el heap limit (hl). Expande el heap
STOREFP
RET 1	; Retorna eliminando el parámetro




.DATA
VT_A: DW lm2@@A

.CODE
lmain@@A:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
RMEM 1 ; Reservamos un lugar para declaracion de la variable local b
RMEM 1 ; Reservamos memoria para el resultado del malloc (la referencia al nuevo CIR del objeto que crearemos)
PUSH 2 ; Apilamos la cant. de vars. de instancia del CIR  + 1 de la referencia a la VT que sera el parametro del malloc
PUSH simple_malloc ; Apliamos la direccion de rutina para alojar memoria en el heap
CALL
DUP ; Para no perder la referencia al nuevo CIR cuando hagamos STOREREF para asociarle la VT
PUSH VT_B ; apilamos la direccion del comienzo de la VT
STOREREF 0 ; Guardamos la referencia a la VT en el CIR que creamos (siempre es en offset 0)
DUP ; Duplicamos la referencia al objeto porque sera tanto el resultado del constructor como la referencia a this dentro de la ejecucion del constructor
PUSH lB@@ ; Apilamos la direccion del constructor que se determina en tiempo de compilacion
CALL
STORE 0 ; almaceno el valor de la expresion en la variable local b
RMEM 1 ; Reservamos un lugar para declaracion de la variable local i
LOAD 0 ; Apilo el valor de la variable local o parametro
RMEM 1 ; Reservo un lugar para el valor de retorno del metodo
SWAP ; Pongo this en el tope de la pila
DUP ; Duplico this para no perderlo al hacer LOADREF
LOADREF 0 ; Cargo la VT
LOADREF 1 ; Cargo el metodo con su offset en la VT
CALL
STORE -1 ; almaceno el valor de la expresion en la variable local i
LOAD -1 ; Apilo el valor de la variable local o parametro
PUSH ldebugPrint@int@Object ; Pongo la etiqueta del metodo
CALL
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z2
RMEM 1 ; Reservamos un lugar para declaracion de la variable local a
RMEM 1 ; Reservamos memoria para el resultado del malloc (la referencia al nuevo CIR del objeto que crearemos)
PUSH 1 ; Apilamos la cant. de vars. de instancia del CIR  + 1 de la referencia a la VT que sera el parametro del malloc
PUSH simple_malloc ; Apliamos la direccion de rutina para alojar memoria en el heap
CALL
DUP ; Para no perder la referencia al nuevo CIR cuando hagamos STOREREF para asociarle la VT
PUSH VT_A ; apilamos la direccion del comienzo de la VT
STOREREF 0 ; Guardamos la referencia a la VT en el CIR que creamos (siempre es en offset 0)
DUP ; Duplicamos la referencia al objeto porque sera tanto el resultado del constructor como la referencia a this dentro de la ejecucion del constructor
PUSH lA@@ ; Apilamos la direccion del constructor que se determina en tiempo de compilacion
CALL
STORE -4 ; almaceno el valor de la expresion en la variable local a
LOAD -4 ; Apilo el valor de la variable local o parametro
RMEM 1 ; Reservo un lugar para el valor de retorno del metodo
SWAP ; Pongo this en el tope de la pila
DUP ; Duplico this para no perderlo al hacer LOADREF
LOADREF 0 ; Cargo la VT
LOADREF 0 ; Cargo el metodo con su offset en la VT
CALL
POP ; La llamada devolvio un valor que no fue asignado en ninguna variable, debe descartarse para no afectar el .STACK
FMEM 5 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 0 ; Retorna de la unidad liberando n lugares en la pila

lm2@@A:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
PUSH 5 ; Apilo un literal entero
PUSH ldebugPrint@int@Object ; Pongo la etiqueta del metodo
CALL
FMEM 0 ; Liberamos las variables locales utilizadas en la unidad al hacer return
RMEM 1 ; Reservamos memoria para el resultado del malloc (la referencia al nuevo CIR del objeto que crearemos)
PUSH 2 ; Apilamos la cant. de vars. de instancia del CIR  + 1 de la referencia a la VT que sera el parametro del malloc
PUSH simple_malloc ; Apliamos la direccion de rutina para alojar memoria en el heap
CALL
DUP ; Para no perder la referencia al nuevo CIR cuando hagamos STOREREF para asociarle la VT
PUSH VT_B ; apilamos la direccion del comienzo de la VT
STOREREF 0 ; Guardamos la referencia a la VT en el CIR que creamos (siempre es en offset 0)
DUP ; Duplicamos la referencia al objeto porque sera tanto el resultado del constructor como la referencia a this dentro de la ejecucion del constructor
PUSH lB@@ ; Apilamos la direccion del constructor que se determina en tiempo de compilacion
CALL
STORE 4 ; Colocamos el valor de la expresion en la locacion reservada para el retorno
STOREFP ; Actualizamos el FP para que apunte al RA del llamador
RET 1 ; Retornamos de la unidad liberando n lugares en la pila
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lA@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_B: DW lm2@@A,linstanciar@@B

.CODE
linstanciar@@B:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
RMEM 1 ; Reservamos un lugar para declaracion de la variable local x
PUSH 100 ; Apilo un literal entero
STORE 0 ; almaceno el valor de la expresion en la variable local x
RMEM 1 ; Reservamos un lugar para declaracion de la variable local rr
RMEM 1 ; Reservamos un lugar para declaracion de la variable local r2
RMEM 1 ; Reservamos un lugar para declaracion de la variable local apsEsMuyMala
PUSH 1 ; Apilo true
STORE -3 ; almaceno el valor de la expresion en la variable local apsEsMuyMala
RMEM 1 ; Reservamos un lugar para declaracion de la variable local zrr5
LOAD 0 ; Apilo el valor de la variable local o parametro
PUSH 5 ; Apilo un literal entero
GT
BF l_else0
PUSH 20 ; Apilo un literal entero
PUSH ldebugPrint@int@Object ; Pongo la etiqueta del metodo
CALL
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z
RMEM 1 ; Reservamos un lugar para declaracion de la variable local a
PUSH 0 ; Apilo un literal entero
STORE -6 ; almaceno el valor de la expresion en la variable local a
l_comienzoFor0:
LOAD -6 ; Apilo el valor de la variable local o parametro
RMEM 1 ; Reservamos memoria para el resultado del malloc (la referencia al nuevo CIR del objeto que crearemos)
PUSH 2 ; Apilamos la cant. de vars. de instancia del CIR  + 1 de la referencia a la VT que sera el parametro del malloc
PUSH simple_malloc ; Apliamos la direccion de rutina para alojar memoria en el heap
CALL
DUP ; Para no perder la referencia al nuevo CIR cuando hagamos STOREREF para asociarle la VT
PUSH VT_C ; apilamos la direccion del comienzo de la VT
STOREREF 0 ; Guardamos la referencia a la VT en el CIR que creamos (siempre es en offset 0)
DUP ; Duplicamos la referencia al objeto porque sera tanto el resultado del constructor como la referencia a this dentro de la ejecucion del constructor
PUSH lC@@ ; Apilamos la direccion del constructor que se determina en tiempo de compilacion
CALL
RMEM 1 ; Reservo un lugar para el valor de retorno del metodo
SWAP ; Pongo this en el tope de la pila
DUP ; Duplico this para no perderlo al hacer LOADREF
LOADREF 0 ; Cargo la VT
LOADREF 2 ; Cargo el metodo con su offset en la VT
CALL
LT
BF l_finFor0
RMEM 1 ; Reservamos un lugar para declaracion de la variable local k
RMEM 1 ; Reservamos un lugar para declaracion de la variable local kx
LOAD -3 ; Apilo el valor de la variable local o parametro
BF l_finIf1
FMEM 9 ; Liberamos las variables locales utilizadas en la unidad al hacer return
PUSH 88888 ; Apilo un literal entero
STORE 4 ; Colocamos el valor de la expresion en la locacion reservada para el retorno
STOREFP ; Actualizamos el FP para que apunte al RA del llamador
RET 1 ; Retornamos de la unidad liberando n lugares en la pila
l_finIf1: NOP
FMEM 2 ; Liberamos las variables locales utilizadas en el bloque actual
LOAD -6 ; Apilo el valor de la variable local o parametro
PUSH 1 ; agregamos un 1 para incrementar la variable en la pila
ADD ; obtenemos la expresion resultante del incremento
STORE -6 ; Guardo el valor de la expresión en la variable
JUMP l_comienzoFor0
l_finFor0: NOP
FMEM 1 ; Liberamos las variables locales utilizadas en el bloque actual
FMEM 1 ; Liberamos las variables locales utilizadas en el bloque actual
JUMP l_finIf0
l_else0:
PUSH 20 ; Apilo un literal entero
PUSH ldebugPrint@int@Object ; Pongo la etiqueta del metodo
CALL
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z
FMEM 6 ; Liberamos las variables locales utilizadas en la unidad al hacer return
PUSH 50 ; Apilo un literal entero
STORE 4 ; Colocamos el valor de la expresion en la locacion reservada para el retorno
STOREFP ; Actualizamos el FP para que apunte al RA del llamador
RET 1 ; Retornamos de la unidad liberando n lugares en la pila
FMEM 1 ; Liberamos las variables locales utilizadas en el bloque actual
JUMP l_finIf0
l_finIf0: NOP
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z2
RMEM 1 ; Reservamos un lugar para declaracion de la variable local z5
PUSH 10 ; Apilo un literal entero
PUSH ldebugPrint@int@Object ; Pongo la etiqueta del metodo
CALL
FMEM 8 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lB@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_C: DW lm2@@A,linstanciar@@B,lmA@@C,lm8@@C

.CODE
lmA@@C:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en la unidad al hacer return
PUSH 5 ; Apilo un literal entero
STORE 4 ; Colocamos el valor de la expresion en la locacion reservada para el retorno
STOREFP ; Actualizamos el FP para que apunte al RA del llamador
RET 1 ; Retornamos de la unidad liberando n lugares en la pila
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lm8@@C:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lC@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_Object: NOP

.CODE
ldebugPrint@int@Object:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lObject@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_LAKD: DW lm1@@LAKD

.CODE
lm1@@LAKD:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila

lLAKD@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_System: NOP

.CODE
lread@@System:
LOADFP
LOADSP
STOREFP
READ    ; Lectura de un valor entero
STORE 3 ; Ponemos el tope de la pila en la locación reservada. En 1 esta ED y en 2 PR, no hay this ni parametros
STOREFP
RET 0 ; +0 ya que no tiene this y no tiene parametros formales

lprintCln@char@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
CPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintC@char@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
CPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintBln@boolean@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
BPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintI@int@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintIln@int@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintSln@String@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro que es una referencia al String en la heap
SPRINT
PRNLN
STOREFP
RET 1

lprintB@boolean@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
BPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintS@String@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro que es una referencia al String en la heap
SPRINT
STOREFP
RET 1

lprintln@@System:
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 0 ; +0 ya que no tiene this y no tiene parametros formales

lSystem@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



