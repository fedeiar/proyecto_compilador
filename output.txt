.CODE

PUSH simple_heap_init 
CALL
PUSH lmain@@Init
CALL
HALT

simple_heap_init: 
RET 0 ; Retorna inmediatamente

simple_malloc:
LOADFP	; Inicialización unidad
LOADSP
STOREFP ; Finaliza inicialización del RA
LOADHL	; hl
DUP	; hl
PUSH 1	; 1
ADD	; hl+1
STORE 4 ; Guarda el resultado (un puntero a la primer celda de la región de memoria)
LOAD 3	; Carga la cantidad de celdas a alojar (parámetro que debe ser positivo)
ADD
STOREHL ; Mueve el heap limit (hl). Expande el heap
STOREFP
RET 1	; Retorna eliminando el parámetro




.DATA
VT_A1: NOP

.CODE
lA1@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_A: NOP

.CODE
lA@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_Init: NOP

.CODE
lmain@@Init:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
RMEM 1 ; Reservamos un lugar para declaracion de la variable local s
RMEM 1
PUSH 67
PUSH simple_malloc
CALL
DUP
PUSH 'a'
STOREREF 0
DUP
PUSH ' '
STOREREF 1
DUP
PUSH 'c'
STOREREF 2
DUP
PUSH 'o'
STOREREF 3
DUP
PUSH 'n'
STOREREF 4
DUP
PUSH 't'
STOREREF 5
DUP
PUSH 'i'
STOREREF 6
DUP
PUSH 'n'
STOREREF 7
DUP
PUSH 'u'
STOREREF 8
DUP
PUSH 'a'
STOREREF 9
DUP
PUSH 'c'
STOREREF 10
DUP
PUSH 'i'
STOREREF 11
DUP
PUSH 'o'
STOREREF 12
DUP
PUSH 'n'
STOREREF 13
DUP
PUSH ' '
STOREREF 14
DUP
PUSH 'v'
STOREREF 15
DUP
PUSH 'i'
STOREREF 16
DUP
PUSH 'e'
STOREREF 17
DUP
PUSH 'n'
STOREREF 18
DUP
PUSH 'e'
STOREREF 19
DUP
PUSH ' '
STOREREF 20
DUP
PUSH 'u'
STOREREF 21
DUP
PUSH 'n'
STOREREF 22
DUP
PUSH ' '
STOREREF 23
DUP
PUSH 's'
STOREREF 24
DUP
PUSH 't'
STOREREF 25
DUP
PUSH 'r'
STOREREF 26
DUP
PUSH 'i'
STOREREF 27
DUP
PUSH 'n'
STOREREF 28
DUP
PUSH 'g'
STOREREF 29
DUP
PUSH ' '
STOREREF 30
DUP
PUSH 'v'
STOREREF 31
DUP
PUSH 'a'
STOREREF 32
DUP
PUSH 'c'
STOREREF 33
DUP
PUSH 'i'
STOREREF 34
DUP
PUSH 'o'
STOREREF 35
DUP
PUSH ','
STOREREF 36
DUP
PUSH ' '
STOREREF 37
DUP
PUSH 'e'
STOREREF 38
DUP
PUSH 's'
STOREREF 39
DUP
PUSH 'p'
STOREREF 40
DUP
PUSH 'e'
STOREREF 41
DUP
PUSH 'r'
STOREREF 42
DUP
PUSH 'e'
STOREREF 43
DUP
PUSH 'm'
STOREREF 44
DUP
PUSH 'o'
STOREREF 45
DUP
PUSH 's'
STOREREF 46
DUP
PUSH ' '
STOREREF 47
DUP
PUSH 'q'
STOREREF 48
DUP
PUSH 'u'
STOREREF 49
DUP
PUSH 'e'
STOREREF 50
DUP
PUSH ' '
STOREREF 51
DUP
PUSH 'n'
STOREREF 52
DUP
PUSH 'o'
STOREREF 53
DUP
PUSH ' '
STOREREF 54
DUP
PUSH 's'
STOREREF 55
DUP
PUSH 'e'
STOREREF 56
DUP
PUSH ' '
STOREREF 57
DUP
PUSH 'r'
STOREREF 58
DUP
PUSH 'o'
STOREREF 59
DUP
PUSH 'm'
STOREREF 60
DUP
PUSH 'p'
STOREREF 61
DUP
PUSH 'a'
STOREREF 62
DUP
PUSH '.'
STOREREF 63
DUP
PUSH '.'
STOREREF 64
DUP
PUSH '.'
STOREREF 65
DUP
PUSH 0
STOREREF 66
STORE 0 ; almaceno el valor de la expresion en la variable local s
LOAD 0 ; Apilo el valor de la variable local o parametro
PUSH lprintSln@String@System ; Pongo la etiqueta del metodo
CALL
RMEM 1
PUSH 1
PUSH simple_malloc
CALL
DUP
PUSH 0
STOREREF 0
PUSH lprintSln@String@System ; Pongo la etiqueta del metodo
CALL
PUSH lprintln@@System ; Pongo la etiqueta del metodo
CALL
RMEM 1
PUSH 9
PUSH simple_malloc
CALL
DUP
PUSH 'e'
STOREREF 0
DUP
PUSH 'x'
STOREREF 1
DUP
PUSH 'i'
STOREREF 2
DUP
PUSH 't'
STOREREF 3
DUP
PUSH 'o'
STOREREF 4
DUP
PUSH '!'
STOREREF 5
DUP
PUSH '!'
STOREREF 6
DUP
PUSH '!'
STOREREF 7
DUP
PUSH 0
STOREREF 8
PUSH lprintS@String@System ; Pongo la etiqueta del metodo
CALL
FMEM 1 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 0 ; Retorna de la unidad liberando n lugares en la pila

lInit@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_B: NOP

.CODE
lB@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_C: NOP

.CODE
lC@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_Object: NOP

.CODE
ldebugPrint@int@Object:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lObject@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



.DATA
VT_System: NOP

.CODE
lread@@System:
LOADFP
LOADSP
STOREFP
READ    ; Lectura de un valor entero
STORE 3 ; Ponemos el tope de la pila en la locación reservada. En 1 esta ED y en 2 PR, no hay this ni parametros
STOREFP
RET 0 ; +0 ya que no tiene this y no tiene parametros formales

lprintCln@char@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
CPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintC@char@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
CPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintBln@boolean@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
BPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintI@int@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintIln@int@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
IPRINT
PRNLN
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintSln@String@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro que es una referencia al String en la heap
SPRINT
PRNLN
STOREFP
RET 1

lprintB@boolean@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro
BPRINT
STOREFP
RET 1 ; Retornamos del metodo liberando el parametro

lprintS@String@System:
LOADFP
LOADSP
STOREFP
LOAD 3 ; Cargamos el primer parametro que es una referencia al String en la heap
SPRINT
STOREFP
RET 1

lprintln@@System:
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 0 ; +0 ya que no tiene this y no tiene parametros formales

lSystem@@:
LOADFP  ; Guarda en la pila el enlace dinámico al comienzo del RA del llamador.
LOADSP  ; Apila el lugar donde comienza el RA de la unidad llamada
STOREFP ; Actualiza el FP para que apunte al comienzo del RA de la unidad llamada.
FMEM 0 ; Liberamos las variables locales utilizadas en el bloque actual
STOREFP
RET 1 ; Retorna de la unidad liberando n lugares en la pila



